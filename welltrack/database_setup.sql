-- Create user_locations table for storing user position data
-- Updated to work with existing users table (bigint id, not UUID)
CREATE TABLE IF NOT EXISTS user_locations (
  id bigint generated by default as identity not null,
  user_id bigint REFERENCES public.users(id) ON DELETE CASCADE,
  latitude DOUBLE PRECISION NOT NULL,
  longitude DOUBLE PRECISION NOT NULL,
  privacy_location BOOLEAN DEFAULT TRUE, -- Allow location sharing
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT user_locations_pkey PRIMARY KEY (id)
);

-- Create unique index on user_id to ensure one location per user
CREATE UNIQUE INDEX IF NOT EXISTS user_locations_user_id_unique 
ON user_locations (user_id);

-- Create index for location queries
CREATE INDEX IF NOT EXISTS user_locations_lat_lng_idx 
ON user_locations (latitude, longitude);

-- Create index for timestamp queries
CREATE INDEX IF NOT EXISTS user_locations_updated_at_idx 
ON user_locations (updated_at);

-- Add privacy column to existing users table if it doesn't exist
ALTER TABLE public.users 
ADD COLUMN IF NOT EXISTS privacy_visible BOOLEAN DEFAULT TRUE;

-- Enable Row Level Security (RLS) on user_locations
ALTER TABLE user_locations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to recreate them
DROP POLICY IF EXISTS "Users can view their own location" ON user_locations;
DROP POLICY IF EXISTS "Users can view others' locations if both allow sharing" ON user_locations;
DROP POLICY IF EXISTS "Users can insert their own location" ON user_locations;
DROP POLICY IF EXISTS "Users can update their own location" ON user_locations;

-- Create more permissive RLS policies for user_locations
-- Policy 1: Users can do anything with their own location
CREATE POLICY "Users can manage their own location" ON user_locations
  FOR ALL USING (
    user_id = COALESCE(
      -- First try to get user_id from JWT metadata
      (auth.jwt() -> 'user_metadata' ->> 'user_id')::bigint,
      -- Then try to get from users table by email
      (SELECT id FROM public.users WHERE email = auth.jwt() ->> 'email' LIMIT 1)
    )
  );

-- Policy 2: Anyone can view locations where privacy is enabled
-- This is more permissive to help with debugging
CREATE POLICY "Anyone can view public locations" ON user_locations
  FOR SELECT USING (
    privacy_location = TRUE 
    AND EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.id = user_locations.user_id 
      AND (users.privacy_visible = TRUE OR users.privacy_visible IS NULL)
    )
  );

-- Policy 3: Allow authenticated users to insert their location
CREATE POLICY "Authenticated users can insert location" ON user_locations
  FOR INSERT WITH CHECK (
    auth.role() = 'authenticated'
    AND user_id = COALESCE(
      (auth.jwt() -> 'user_metadata' ->> 'user_id')::bigint,
      (SELECT id FROM public.users WHERE email = auth.jwt() ->> 'email' LIMIT 1)
    )
  );

-- Policy 4: Allow authenticated users to update their location
CREATE POLICY "Authenticated users can update location" ON user_locations
  FOR UPDATE USING (
    auth.role() = 'authenticated'
    AND user_id = COALESCE(
      (auth.jwt() -> 'user_metadata' ->> 'user_id')::bigint,
      (SELECT id FROM public.users WHERE email = auth.jwt() ->> 'email' LIMIT 1)
    )
  );

-- Create function to automatically clean old location data (optional)
CREATE OR REPLACE FUNCTION cleanup_old_locations()
RETURNS void AS $$
BEGIN
  DELETE FROM user_locations 
  WHERE updated_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

-- Create function to update proximity notifications (optional)
CREATE OR REPLACE FUNCTION notify_proximity_changes()
RETURNS trigger AS $$
BEGIN
  -- This could trigger real-time notifications when users come into proximity
  -- For now, it just updates the timestamp
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic timestamp updates
DROP TRIGGER IF EXISTS update_user_locations_updated_at ON user_locations;
CREATE TRIGGER update_user_locations_updated_at
  BEFORE UPDATE ON user_locations
  FOR EACH ROW
  EXECUTE FUNCTION notify_proximity_changes();

-- Create or replace function to get nearby users (stored procedure approach)
CREATE OR REPLACE FUNCTION get_nearby_users(
  current_user_id bigint,
  user_lat DOUBLE PRECISION,
  user_lng DOUBLE PRECISION,
  radius_meters DOUBLE PRECISION DEFAULT 1000
)
RETURNS TABLE (
  user_id bigint,
  name text,
  email text,
  avatar character varying,
  mental_state mental_states,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  distance_meters DOUBLE PRECISION,
  updated_at TIMESTAMP WITH TIME ZONE
) 
LANGUAGE plpgsql
SECURITY DEFINER  -- This allows the function to bypass RLS
AS $$
BEGIN
  -- Handle infinite or very large radius (worldwide search)
  IF radius_meters > 20037508 OR radius_meters = 'infinity' THEN
    RETURN QUERY
    SELECT 
      u.id,
      u.name,
      u.email,
      u.avatar,
      u.mental_state,
      ul.latitude,
      ul.longitude,
      (6371000 * acos(
        LEAST(1.0, -- Prevent acos domain error
          cos(radians(user_lat)) * 
          cos(radians(ul.latitude)) * 
          cos(radians(ul.longitude) - radians(user_lng)) + 
          sin(radians(user_lat)) * 
          sin(radians(ul.latitude))
        )
      )) as distance_meters,
      ul.updated_at
    FROM public.users u
    INNER JOIN user_locations ul ON u.id = ul.user_id
    WHERE u.id != current_user_id
      AND (u.privacy_visible = TRUE OR u.privacy_visible IS NULL)
      AND ul.privacy_location = TRUE
    ORDER BY distance_meters;
  ELSE
    -- Normal radius-limited search
    RETURN QUERY
    SELECT 
      u.id,
      u.name,
      u.email,
      u.avatar,
      u.mental_state,
      ul.latitude,
      ul.longitude,
      (6371000 * acos(
        LEAST(1.0, -- Prevent acos domain error
          cos(radians(user_lat)) * 
          cos(radians(ul.latitude)) * 
          cos(radians(ul.longitude) - radians(user_lng)) + 
          sin(radians(user_lat)) * 
          sin(radians(ul.latitude))
        )
      )) as distance_meters,
      ul.updated_at
    FROM public.users u
    INNER JOIN user_locations ul ON u.id = ul.user_id
    WHERE u.id != current_user_id
      AND (u.privacy_visible = TRUE OR u.privacy_visible IS NULL)
      AND ul.privacy_location = TRUE
      AND (6371000 * acos(
        LEAST(1.0,
          cos(radians(user_lat)) * 
          cos(radians(ul.latitude)) * 
          cos(radians(ul.longitude) - radians(user_lng)) + 
          sin(radians(user_lat)) * 
          sin(radians(ul.latitude))
        )
      )) <= radius_meters
    ORDER BY distance_meters;
  END IF;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION get_nearby_users TO authenticated;

-- Debug function to check current user and nearby users
CREATE OR REPLACE FUNCTION debug_proximity_info(user_email text)
RETURNS TABLE (
  info_type text,
  info_value text
) AS $$
DECLARE
  current_user_id bigint;
  current_location RECORD;
BEGIN
  -- Get user ID from email
  SELECT id INTO current_user_id FROM public.users WHERE email = user_email;
  
  -- Return current user info
  RETURN QUERY SELECT 'current_user_id'::text, COALESCE(current_user_id::text, 'Not found');
  
  -- Get current user's location
  SELECT * INTO current_location FROM user_locations WHERE user_id = current_user_id;
  
  IF current_location IS NOT NULL THEN
    RETURN QUERY SELECT 'current_location'::text, 
      format('lat: %s, lng: %s', current_location.latitude, current_location.longitude);
  ELSE
    RETURN QUERY SELECT 'current_location'::text, 'No location found';
  END IF;
  
  -- Count total locations
  RETURN QUERY SELECT 'total_user_locations'::text, 
    (SELECT COUNT(*)::text FROM user_locations);
  
  -- Count visible users
  RETURN QUERY SELECT 'visible_user_locations'::text, 
    (SELECT COUNT(*)::text FROM user_locations ul 
     JOIN users u ON ul.user_id = u.id 
     WHERE ul.privacy_location = TRUE 
     AND (u.privacy_visible = TRUE OR u.privacy_visible IS NULL));
  
  -- List all user locations
  RETURN QUERY 
    SELECT 
      format('user_%s_location', ul.user_id)::text,
      format('name: %s, lat: %s, lng: %s, privacy: %s', 
        u.name, ul.latitude, ul.longitude, 
        CASE WHEN ul.privacy_location AND (u.privacy_visible OR u.privacy_visible IS NULL) 
             THEN 'visible' ELSE 'hidden' END)::text
    FROM user_locations ul
    JOIN users u ON ul.user_id = u.id;
END;
$$ LANGUAGE plpgsql; 